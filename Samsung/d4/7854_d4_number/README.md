# 7854. 최약수

[링크](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWttVkiq5jEDFASy&categoryId=AWttVkiq5jEDFASy&categoryType=CODE)

난이도 : d4
정답률 : \_66%

## 설계

X는 10^9까지이다.

최약수 : 1 2 5 10 20 25 50 100 125 200 ...

잘 보면 이는 모두 10의 N제곱을 1~10으로 나눴을 때의 몫이 자연수인 경우이다.

위 방법을 이용하면 시간복잡도는 최악의 경우도 100번 이내가 된다.

모든 자리수에 대해 10번씩만 비교하면 되기 때문. (10의 9승 까지, 9 \* 10)

이 때, 나누기 1과 나누기 10의 경우 이전, 다음 경우와 중복이 발생할 수 있다.

따라서 나누기 1은 제외하고 수행하지 않는다.

## 정리

내 코드 : 6ms;
빠른 코드 : 3ms;

처음 X를 입력받으면, X\*10 보다 작은 10의 제곱 까지만 탐색을 수행한다.

1. while문 에서 반복문으로 2~10 까지 현재 10의 자리수를 나누어 최약수를 구한다.
2. 10의 자리수를 증가 (10을 곱함)시킨다.
3. 증가한 10의 자리수가 X\*10보다 크면 중단한다.

이렇게 구한 값들을 벡터에 모으고, 정렬시킨다.

벡터를 탐색하면서 X 이하인 값들만 count한다.

## 고생한 점

### 10의 N제곱을 1~10으로 나눴을 때의 몫이 자연수인 경우를 판단

```cpp
long long mock = decimal / i;

if (mock * i == decimal) {
  // 몫이 자연수인 경우
}
```

위와 같이 나누고, 곱해서 값이 똑같은지 확인.

정수형에서 버리는 값의 성질을 이용.
