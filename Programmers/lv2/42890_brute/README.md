# 42890. 후보키

[링크](https://programmers.co.kr/learn/courses/30/lessons/42890)

| 난이도 | 완료(명) |
| :----: | :------: |
|  lv2   |   1496   |

## 설계

### 시간복잡도

컬럼(column)의 길이는 1 이상 8 이하, 로우(row)의 길이는 1 이상 20 이하 이다.

컬럼은 속성이고, 각 속성들의 집합이 후보키가 될 수 있는지 판단해야 한다.

다음 방법을 이용해 모든 후보키의 집합을 탐색한다.

- 브루트 포스

이를 최대 검사하려면 2^8 번 만큼의 연산이 필요하고 이는 256번이다.

각 속성들을 후보키로 만들었을 때 key값을 작성하는 로직은 다음과 같이 수행한다.

```cpp
new_key[i] = key_1[i] + "/" + key_2[i];
```

이 방법을 수행하면 한 후보키당 key는 최대 20번씩 생성된다.

하나의 후보키가 다른 후보키들에 속해있는지 검사하는 시간복잡도는 다음과 같다.

가능한 후보키의 수 만큼 후보키 집합에서 검사하므로 256^2 번 수행한다.

위 시간복잡도들을 다 곱하는 경우가 최악의 시간복잡도이며, 이는 다음과 같다.

```cpp
256^3 * 20 = 335,544,320
```

이는 1초 안에 풀이가 가능하다.

### 후보키의 순회

후보키로 택하는 키의 수를 1부터 증가시키며 검색해 나가야한다.

예를 들어 다음과 같은 경우가 후보키가 될 수 있다고 하자.

```cpp
// 각 index의 값이 1일때 index번째 key를 후보키 집합에 포함함을 의미
1000
1100
1110
1111
```

위 네가지 경우 모두 "1000" 과 같은 이유로 후보키가 되는것이 가능하다.

따라서 후보키로 정할 수 있는 키의 수를 1개부터 증가시키며 경우를 탐색해야 중복되는 경우를 막을 수 있다.

경우의 수 조합은 next_permutation을 이용해 수행한다.

```cpp
for (int count = 1; count <= cols; count++) {
  vector<bool> bits(cols - count, false);

  for (int i = 0; i < count; i++) {
    bits.push_back(true);
  }

  do {
    // do something
  } while (next_permutation(bits.begin(), bits.end()));
}
```

위 경우 모든 경우의 수를 생성 가능하며, 포함하는 키의 수가 적은 경우부터 생성한다.

### 후보키 생성

새로운 후보키를 생성할 때의 키 값은, 포함되는 키 (문자열)의 합으로 표현할 수 있다.

따라서 아래와 같은 방법으로 표현이 가능하다.

```cpp
new_key[i] = key_1[i] + "/" + key_2[i];
```

중간에 특수문자를 포함하지 않는 경우 다음 경우에 문제가 생긴다.

```cpp
"abc" + "de"
"ab" + "cde"
```

두 경우는 분명히 다른 경우이지만, 합칠경우 같은 값이 되어버린다.

따라서 문제 조건에서 key값에 포함되지 않는 문자열을 추가해 이를 구분해준다.

이렇게 생성한 key 값들이 후보키가 될 수 있는지는 map을 이용해 판단한다.

```cpp
map<string, bool> m;

for (string key : new_keys) {
  m[s] = true;
}

if(map.size() == rows){
  // 정답인 경우
}
```

### 후보키의 중복 여부 판단

위 방법을 이용하면 후보키 집합들은 키의 수가 적은 순서대로 생성되며, 정답의 경우도 마찬가지이다.

따라서 현재 정답인지 확인하고 싶은 후보키 집합은, 이전에 정답인 경우의 키의 수 이상으로 키의 수를 가지는 것이 보장된다.

따라서 정답들을 순회하며 현재 경우가 정답인 경우를 포함하고 있는지 판단하면 된다.

알고리즘은 다음과 같다.

- 현재 index에서 정답은 키를 포함하고 있지만, 검사하고자 하는 target은 키를 포함하지 않은경우
  - 이 경우는 새로운 후보키이다.

```cpp
// 정답들과 현재 경우 모두 문자열로 생성
bool has_contain(string target) {
  // target이 1의 수가 더 많음
  for (string answer : answers) {
    bool flag = true;

    for (int i = 0; i < target.length(); i++) {
      // 정답을 현재경우가 포함하지 않는 경우
      if (answer[i] == '1' && target[i] == '0') {
        flag = false;
        break;
      }
    }

    if (flag) {
      return true;
    }
  }
  return false;
}
```

## 고생한 점

후보키를 다음과 같이 생성할 수 있는경우를 살펴보자.

1과 0의 의미는 각 index의 속성이 후보키에 포함되는지 여부이다.

```cpp
1100
0111
```

위 두 후보키는 다르므로 현재 후보키가 다른 후보키에 속해있는지 판단하는 로직을 단순 포함으로만 작성하면 안된다.
