# 43237. 예산

[링크](https://programmers.co.kr/learn/courses/30/lessons/43237)

| 난이도 | 정답률(\_%) |
| :----: | :---------: |
|  lv3   |    낮음     |

## 설계

### 시간복잡도

지방의 수는 최대 100,000 까지 이다.

지방마다 요청하는 예산의 범위는 1 이상 100,000 이하 이므로 문제에서 설정해야 하는 예산의 가짓수는 최대 100,000가지이다.

지방마다 배정하는 예산을 계산할 때 지방의 수만큼의 연산을, 각 예산의 수만큼 반복하므로 완전탐색을 이용할 경우 시간복잡도는 O(10,000,000,000‬) 이며 제한시간 내에 불가능하다.

따라서 이분 탐색을 이용해 다음의 시간을 줄인다.

- 설정한 예산의 값
- 모든 지방에 할당되는 예산의 총 합

### 예산의 총 합

각 지방마다 요청하는 예산들을 정렬할 경우, lower_bound를 이용해 설정된 예산 이상으로 요청하는 지방이 몇 개인지 구할 수 있다.

여기서 요청하는 예산들의 합을 메모이제이션 해놓을 경우 예산의 총 합은 다음과 같다.

```cpp
int target // 현재 설정된 예산

int count = lower_bound(budgets.begin(), budgets.end(), target)
sum = dp[budgets.size() - count] + target * count;
```

각 과정별 소요되는 시간복잡도는 다음과 같다.

- 예산을 정렬하는데 : NlogN
- 예산 이상으로 요청하는 갯수를 찾을 때 : logN
- 총 합을 구할 경우 : logN

이와 달리 매번 예산의 총 합을 반복문을 통해 계산할 경우 다음과 같다.

- target을 설정하는데 : logM
- 총 합을 구할 경우 : N

지방의 수와 지방에서 요청하는 범위는 둘다 같은 100,000 까지 이므로 각 방법 모두 시간복잡도는 동일하다.

### 이분 탐색

각 지방에서 요청할 수 있는 범위는 입력된 예산들 중 최대값 까지이다.

최소값은 0부터 시작해야 하는데, 이는 M/budget.size() 가 budgets 중 최소값보다 작을 수 있기 때문이다.

따라서 이분 탐색의 범위를 다음과 같이 설정한다.

```cpp
// 0 ~ max(budget)

// 예산들이 오름차순으로 정렬되어있다고 가정
int min = 0;
int max = budgets.back() + 1;
```

아래와 같이 이분탐색을 수행한다.

```cpp
while (min + 1 < max) {
  int mid = (min + max) / 2;

  // 현재 예산 mid를 이용해 sum을 구함

  if (sum <= M) {
    min = mid;
  } else {
    max = mid;
  }
}
```

합이 M 이하인 경우 min을 증가시키고, M을 초과한 경우 max를 감소시킨다.

여기서 while문의 조건이 min + 1 < max 임에 유의한다.

따라서 while문을 탈출한 경우 min값이 설정할 예산이다.

## 고생한 점

한계를 1씩 증가시키며 테스트하는 것이 아니라 이분탐색으로 찾아야 제한시간 내에 풀이가 가능하다.
