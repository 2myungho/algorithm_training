# 3190. 뱀

[링크](https://www.acmicpc.net/problem/3190)

| 난이도 | 정답률(\_%) |
| :----: | :---------: |
| Gold V |   34.716    |

## 설계

### 시간 복잡도

지도의 최대 크기는 100^2 이다.

방향 이동이 주어졌을 때 원래 원래 부딛힐 지점에서 회피한다고 생각하자.

제일 오래 살아남는 경우 마지막 방향 이동이 주어진 후 지도의 크기 100 초만큼 더 살 수 있을것이다.

방향 이동에서 주어지는 시간의 최대 값은 10,000 이므로, 최악의 경우도 10,100 초 이내에 게임이 끝난다.

따라서 시간복잡도는 O(10100) 이며 이는 제한시간 내에 충분하다.

### 공간 복잡도

지도에 표시해야 될 내용들은 다음과 같다.

- 아무것도 없음
- 뱀의 몸이 존재
- 사과가 존재

따라서 int형으로 지도를 100^2 사이즈로 구성한다.

### 시뮬레이션

뱀의 이동은 다음 순서를 따른다.

1. 시간의 증가
2. 다음으로 이동할 좌표 계산 (현재 진행방향을 고려)
3. 좌표로 이동이 유효한지 계산
   - 벽에 부딛힘
   - 자신의 몸과 부딛힘
4. 몸 증가
5. 방향을 이동하는 경우 방향을 변경함

뱀이 가져야 할 정보는 다음 2가지이다.

- 몸의 좌표들
- 현재 방향

몸의 좌표는 이동 후 머리가 추가되고 꼬리가 삭제되는 구조이므로 FIFO 구조이다.

따라서 queue로 설정한다.

```cpp
struct Snake {
  queue<Axis> body;
  int direction;
};
```

방향 변경의 경우 시간, 방향이동 두 가지를 입력받아 queue에 관리한다.

이는 방향 정보가 시간초 대로 순서대로 주어짐이 보장되며, 시간의 증가에 따라 현재 시간과 방향의 시간이 맞으면 pop 하면 되기 때문이다.

그리고 방향의 이동은 +1, -1로 index의 변위로 구성한다.

```cpp
struct Move {
  int time, change;
};

// 현재 시간에 방향을 이동해야 하는 경우
if (time == moves.front().time){
  // do something
  moves.pop();
}
```

방향 정보를 시계방향으로 순서대로 설정한다.

그리고 방향의 이동 시 index에 변화가 주어지므로 나머지 연산을 이용해 이를 원형으로 순환하게 만든다.

```cpp
struct Axis {
  int y, x;
};
Axis dirs[4] = {{0, +1}, {+1, 0}, {0, -1}, {-1, 0}};

// mod 연산을 이용해 순환하도록 구성
snake.direction += moves.front().change + 4;
snake.direction %= 4;
```

게임이 끝날 때 까지 while문으로 게임을 진행하며, 부딛힌 경우 break로 탈출한다.

## 정리

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|      0       |       0        |

## 고생한 점

자신의 몸과 부딛히는 경우를 체크해야 한다.

방향의 순서를 잘못 세팅해 오류가 발생
