# 14503. 로봇 청소기

[링크](https://www.acmicpc.net/problem/14503)

| 난이도 | 정답률(\_%) |
| :----: | :---------: |
| Gold V |   51.257    |

## 설계

### 시간 복잡도

현재 위치에서 4방향을 탐색 가능하고, 최악의 경우 모든 구역 50^2에 대해 탐색한다고 가정하자.

또한 현재 위치에서 끝까지 후진하는 경우 최악의 경우 한 변의 최대길이 50만큼 시간복잡도가 소요된다.

따라서 시간 복잡도는

```cpp
O(4*50^2 + 50) = O(10,050)
```

이므로 제한 시간 내에 충분하다.

### 공간 복잡도

벽의 여부, 청소 여부를 나타낼 2차원 배열을 50^2의 크기로 2개 선언한다.

각 배열은 2가지 경우만 표시하면 되므로 bool 형으로 선언한다.

bool 형으로 선언하는 이유는 int형 하나로 관리하는 것보다 메모리의 효율을 위해서이다.

문제에 주어진 대로 각 방향정보를 생성한다.

```cpp
struct Axis {
  int y, x;
};

// 왼쪽 방향을 바라봐야 하므로 CCL 방향임에 유의
Axis dirs[4] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
```

그리고 로봇 구조체를 생성한다.

```cpp
struct Robot {
  int dir;
  Axis axis;
};
```

### 시뮬레이션

테두리의 경우 벽으로 막혀 있으므로 범위 초과 판별은 필요하지 않다.

로봇이 멈출 때 까지 반복해야 하므로 while형으로 감싸고 시뮬레이션을 돌린다.

while문의 중지는 특정 상황에서 구현한다.

한 위치에서 4번 회전했는지 판단하기 위해 전역변수로 회전 횟수를 기록하고, 이동할 때는 이를 초기화한다.

조건은 다음과 같이 나눌 수 있다.

- 왼쪽으로 이동 가능 : 이동
- 왼쪽으로 이동이 불가능
  - 회전횟수가 4 이하면 : 회전
  - 회전횟수가 4 이상
    - 후진 가능 : 후진
    - 후진 불가능 : 종료

따라서 위와 같은 방법으로 구현한다.

이 때 각 경우의 마지막에는 continue 를 붙인다.

```cpp
int turnCount = 0;
while (true) {
  // 청소하지 않았으면 청소

  if (!visited[left.y][left.x] && !wall[left.y][left.x]) {
    // 왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음
    // 한 칸을 전진하고 1번부터 진행한다.
    continue;
  }

    // 왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다.
  if ((visited[left.y][left.x] || wall[left.y][left.x]) && turnCount < 4) {
    // 회전
    turnCount += 1;
    continue;
  }

  if (turnCount == 4) {
    if (wall[back.y][back.x]) {
      // 네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도
      // 할 수 없는 경우에는 작동을 멈춘다.
    }

    // 네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을
    // 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다.

    continue;
  }
}
```

## 정리

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|      0       |       0        |

## 고생한 점

종료되는 경우가 아닌 분기의 경우 continue를 붙여 while문의 처음으로 이동시켜야 한다.

엉뚱한 위치에서 끝나는 경우 다음 testCase에서 문제가 발생한다.

```sh
11 10
7 4 0
1 1 1 1 1 1 1 1 1 1
1 0 0 0 0 0 0 0 0 1
1 0 0 0 1 1 1 1 0 1
1 0 0 1 1 0 0 0 0 1
1 0 1 1 0 0 0 0 0 1
1 0 0 0 0 0 0 0 0 1
1 0 0 0 0 0 0 1 0 1
1 0 0 0 0 0 1 1 0 1
1 0 0 0 0 0 1 1 0 1
1 0 0 0 0 0 0 0 0 1
1 1 1 1 1 1 1 1 1 1
```

아래와 같이 (9,2) 좌표에서 멈춘다.

```sh
  0  0  0  0  0  0  0  0  0  0
  0  0  0  0  0  0  0  0  0  0
  0  0  0  0  0  0  0  0  0  0
  0  0  0  0  0  0  0  0  0  0
  0  0  0  0  0  0  0  0  0  0
  0  0  0 12 11  0  0  0  0  0
  0  0 14 13 10  9  0  0  0  0
  0 16 15  2  1  8  0  0  0  0
  0 17 18  3  4  7  0  0  0  0
  0  0 19 20  5  6  0  0  0  0
  0  0  0  0  0  0  0  0  0  0
```

그러나 제대로 동작하는 경우 다음과 같다

```sh
  0  0  0  0  0  0  0  0  0  0
  0 56 57 46 45 44 43 42 41  0
  0 55 48 47  0  0  0  0 40  0
  0 50 49  0  0 36 37 38 39  0
  0 51  0  0 35 34 31 30  0  0
  0 52 53 12 11 33 32 29 28  0
  0 54 14 13 10  9  0  0 27  0
  0 16 15  2  1  8  0  0 26  0
  0 17 18  3  4  7  0  0 25  0
  0 21 19 20  5  6 22 23 24  0
  0  0  0  0  0  0  0  0  0  0
```
