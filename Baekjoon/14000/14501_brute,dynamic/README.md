# 14501. 퇴사

[링크](https://www.acmicpc.net/problem/14501)

|  난이도   | 정답률(\_%) |
| :-------: | :---------: |
| Silver IV |   47.370    |

## 설계

### 시간복잡도

상담의 갯수 N은 최대 15까지이다.

이 문제는 다음과 같은 방법들로 해결할 수 있다.

- 브루트포스
- 다이나믹 프로그래밍

브루트 포스의 경우를 살펴보자

최악의 경우N번째 상담을 하거나 안하거나의 모든 경우의 수를 세면 2^15 = 32,768 이므로 제한시간 2초 내에 충분하다.

동적계획법으로 푸는 경우를 살펴보자.

한번의 순회로 dp를 갱신하고, 이 중에서 가능한 최대한의 이익을 구하면 되므로 시간복잡도는 O(N) 이다.

이 또한 제한시간 내에 충분하다.

### 공간복잡도

T는 5이하, P는 1,000 이하의 자연수이다. 가능한 이익의 최대 값은 1,000을 15번 수행하는 것으로 15,000이며 int로 충분하다.

### 브루트포스

현재 상담을 선택하는 경우, 선택하지 않는 경우에 따라서 깊이를 늘려 탐색해나간다.

그러나 단순히 상담의 선택 여부에 따른 2^15의 경우가 있는 것이 아닌, 현재 상담을 선택했을 때 퇴사일 내인지를 판별해야한다.

더 탐색을 하지 않는 경우는 다음과 같다.

- 오늘이 퇴사일인경우
- 오늘 선택할 상담이 끝나는 날이 퇴사일을 넘는경우

```cpp
void dfs(int index, int cost) {
  answer = max(answer, cost);

  // 오늘이 퇴사일인 경우
  if (index >= N) {
    return;
  }

  dfs(index + 1, cost);

  // 오늘 선택한 상담이 끝나는 날이 아무리 늦어도 퇴사일 이내일 때
  if (index + infos[index].T <= N) {
    dfs(index + infos[index].T, cost + infos[index].P);
  }
}
```

### 동적계획법

dp 배열을 다음과 같이 선언한다

```cpp
dp[날짜] : 날짜까지 가질 수 있는 이익의 최대 값
```

이 경우 일반식은 다음과 같다.

```cpp
dp[i] = min(dp[i-1],dp[i]);
```

그렇다면 dp[i]의 갱신은 언제 일어날까?

현재 index를 탐색할 때 다음 경우를 고려한다

- 현재 상담을 선택하는 경우
  - dp[현재 날짜 + 상담에 걸리는 일수] 를 갱신한다.
  - 이익 : 현재 까지의 dp값 + 이번 상담의 이익

따라서 현재 상담을 선택했을 때 끝나는 날짜가 유효범위인경우 미래의 dp[i]가 이미 갱신된다.

```cpp
if (i + infos[i].T <= N) {
  dp[i + infos[i].T] = max(dp[i + infos[i].T], dp[i] + infos[i].P);
}
```

위 식은 미래의 dp를 갱신하는 것이므로 dp를 갱신하는 식은 다음과 같다.

```cpp
for (int i = 0; i < N; i++) {
  if (i + infos[i].T <= N) {
    dp[i + infos[i].T] = max(dp[i + infos[i].T], dp[i] + infos[i].P);
    answer = max(answer, dp[i + infos[i].T]);
  }

  dp[i + 1] = max(dp[i + 1], dp[i]);
  answer = max(answer, dp[i + 1]);
}
```

## 정리

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|      0       |       0        |

## 고생한 점
