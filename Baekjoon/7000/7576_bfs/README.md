# 7576. 토마토

[링크](https://www.acmicpc.net/problem/7576)

|  난이도  | 정답률(\_%) |
| :------: | :---------: |
| Silver I |   31.729    |

## 설계

### 시간 복잡도

상자의 크기는 최대 가로 100, 세로 100 인 100^2 배열이다.

최악의 경우 모든 경우를 탐색할 때 100^2 번 탐색해야한다.

각 경우마다 상, 하, 좌, 우 4가지 경우를 탐색한다.

따라서 시간 복잡도는 최악 O(40,000) 이며 이는 제한시간 1초 내에 충분하다.

### 공간 복잡도

토마토는 주변 토마토를 익게 하는데 하루의 시간이 소요된다.

따라서 각 날마다 토마토를 익게 해야 하므로 BFS 탐색을 위한 queue가 필요하다.

상자에 들어갈 수 있는 종류는 다음 세가지이다

- 익은 토마토
- 익지 않은 토마토
- 벽

따라서 int형으로 100^2 크기의 상자를 선언한다.

최악의 경우도 10,000 일 만에 모든 토마토가 익을 수 있으므로 정답 또한 int형으로 선언한다.

### BFS

BFS에 들어가는 데이터는 다음 세가지로 구성한다.

- 현재 날짜
- y 좌표
- x 좌표

```cpp
struct Tomato {
  int day, y, x;
};
```

벽이 없는 경우 익어야할 토마토의 총 개수는 다음과 같다.

```cpp
int total = M * N;
total -= walls; // 벽의 갯수를 빼줌
```

상자의 상태를 입력 받을 때 익은 토마토의 경우 queue에 push한다.

벽인 경우에서는 total에서 빼준다.

중복 검토를 막기 위해 visited 배열을 상자의 크기와 같이 선언해주고, 토마토인 경우에는 true로 check한다.

BFS 탐색은 다음과 같이 수행한다.

```cpp
while (!q.empty()) {
  Day cur = q.front();
  q.pop();
  day = cur.day;

  for (int d = 0; d < 4; d++) {
    Axis next = {cur.y, cur.x};
    next.y += dirs[d].y;
    next.x += dirs[d].x;

    // 탐색이 유효한지 확인
    if(isPossible(next)){
      continue;
    }

    // 유효한 경우 queue에 push
    q.push({cur.day + 1, next.y, next.x});
    visited[next.y][next.x] = true;
    count += 1;
  }
}
```

BFS 탐색이 끝난 경우 익지 않은 토마토가 존재하는지 확인한다.

```cpp
if (count != total) {
  // 익지 않은 토마토가 존재하는 경우
  return;
}
// 모든 토마토가 익은 경우
```

## 정리

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|      88      |       20       |

## 고생한 점
