# 15683. 감시

[링크](https://www.acmicpc.net/problem/15683)

| 난이도 | 정답률(\_%) |
| :----: | :---------: |
| Gold V |   40.754    |

## 설계

### 시간 복잡도

사무실의 최대 크기는 가로, 세로 최대 8 이다.

CCTV의 갯수는 최대 8개이다.

하나의 CCTV당 감시할 수 있는 범위를 탐색하는 데 사무실의 최대 크기의 한 변의 길이를 네번 반복한 만큼 소요된다고 가정하자.

(최악의 경우도 이보다 작음)

각 CCTV당 64번의 탐색이 필요하다.

하나의 CCTV마다 방향은 4 방향을 가질 수 있다. 따라서 8^4번 만큼 탐색을 반복한다.

따라서 총 시간복잡도는

```cpp
O(64*8^4) = O(262,144)
```

이므로 제한시간 1초 내에 충분하다.

### 공간 복잡도

2차원 배열에 들어가는 자료의 종류는 다음과 같다.

- 빈 공간
- 감시 카메라 5개
- 벽

따라서 7가지 종류를 판별해야 하므로 int 형으로 배열을 선언한다.

각 카메라의 경우 좌표와 바라볼 수 있는 방향 정보를 포함한다.

따라서 다음과 같은 구조체로 설정한다.

```cpp
struct Camera {
  vector<int> dirs;
  Axis axis;
};
```

### 탐색

각 카메라 별로 4가지 방향을 바라볼 수 있다. 따라서 DFS로 각 카메라 별로 4가지 방향으로 회전시키며 탐색한다.

이 때, 모든 카메라의 탐색의 끝난 경우에 카메라가 바라보는 방향들로 감시 가능한 부분을 체크해야 한다.

이는 각 경우마다 체크하고 넘어가는 경우, dfs 호출이 끝난 뒤 감시한 부분을 삭제하는 과정에서 감시가 겹치는 부분에 감시가 불가능하다고 체크되기 때문이다.

따라서 dfs는 다음과 같다.

```cpp
void dfs(int index, vector<int> cameraDirs){
  if(index == cameras.size()){
    // 각 카메라들이 바라보는 방향으로 감시 가능한 구역 체크
    // 사각 지대의 갯수를 셈
    answer = min(answer, new_answer);

    // 지도에 체크된 구역을 초기화
  }

  // 각 바라보는 방향을 체크
  for (int i = 0; i < 4; i++) {
    vector<int> cur_dirs = cameraDirs;
    cur_dirs.push_back(i);
    dfs(index + 1, cur_dirs);
  }
}
```

이때 모든 방향을 바라보는 카메라의 경우 backtracking을 이용할 수 있다.

```cpp
  if (cameras[index].dirs.size() == 4) {
    cameraDirs.push_back(0);
    dfs(index + 1, cameraDirs);

    return;
  }
```

## 정리

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|      48      |       0        |

## 고생한 점
