# 12865. 평범한 배낭

[링크](https://www.acmicpc.net/problem/12865)

| 난이도 | 정답률(\_%) |
| :----: | :---------: |
| Gold V |   37.480    |

## 설계

### 시간 복잡도

물건의 수 N 은 최대 100 이다.

브루트 포스 방법을 수행하는 경우 2^100 번 수행하며 이는 1억을 아득히 초과하므로

제한시간 2초 내에 풀이가 불가능하다.

그리디한 방법으로 구하는 경우를 생각해보자

```cpp
W = 30
one = {5kg, $5} // kg당 $1
two = {10kg, $6} // kg당 $0.6
three = {20kg, $14} // kg당 $0.7
```

물건의 무게/가치순으로 배낭에 집어넣는 경우 1번 2번을 넣지만 이는 최적해 (2번 3번)가 아니다.

따라서 동적계획법으로 풀이한다.

dp의 설계는 다음과 같다.

```cpp
int dp[물건의번호][무게]  // N * 100,000
```

최악의 경우 모든 DP를 채우는 경우 10,000,000‬ 번이 걸리며 이는 1억보다 작으므로 제한시간 내에 풀이가 가능하다.

### 공간 복잡도

가치가 최대가 되는 경우는 N이 100, 모든 물건의 가치가 100,000인 경우이며
이는 int형으로 충분하다.

### 동적 계획법

dp의 설계는 다음과 같다.

```cpp
int dp[물건의 번호][가능한 무게]
// 물건의 번호까지 물건을 채울 수 있을 때 가질 수 있는 가치의 최대
```

즉 현재 주어진 배낭이 포함할 수 있는 물건들의 총 합에서 최선의 가치를 가진다.

그리고 이는 아래의 성질을 지닌다.

- 현재 집합이 i번째 물건을 포함하고 있지 않다면, i번째 보석을 뺀 나머지 물건들 중에서 최적의 해이다.
- 현재 집합가 i번째 보석을 포함하고 있다면, 속한 보석들의 총 가격은 i-1개의 보석들 중에서 최적으로 고른 가격의 합에다가 현재 물건의 가치을 더한 것과 같다.
- (단, i번째 보석을 넣었을 때 배낭이 터지지 않아야 한다)

따라서 dp를 순회하며 이전 물건 번호 까지의 결과를 이용해 dp를 갱신해 나간다.

따라서 일반식은 다음과 같다.

```cpp
// 현재 물건을 포함했을 때 남은 무게로 채울 수 있는 가치의 최대
// 현재 물건을 포함하지 않을 때 현재 무게에서 가질 수 있는 가치의 최대
dp[n][w] = max(loads[n - 1].V + dp[n - 1][w - loads[n - 1].W], dp[n - 1][w]);
```

초기 값은 다음과 같다.

```cpp
dp[0][~] = 0
dp[~][0] = 0
```

이는 i번째가 0인 경우 아무것도 배낭에 넣을 수 없고, 가능한 배낭의 무게가 0인 경우 또한 마찬가지 이기 때문이다.

## 정리

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|      36      |       4        |

## 고생한 점
