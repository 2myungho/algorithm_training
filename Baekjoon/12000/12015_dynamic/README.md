# 12015. 가장 긴 증가하는 부분 수열 2

[링크](https://www.acmicpc.net/problem/12015)

| 난이도  | 정답률(\_%) |
| :-----: | :---------: |
| Gold II |   46.457    |

## 설계

### 시간 복잡도

수열의 크기가 최대 1,000,000 이다.

모든 경우를 탐색하는 경우 N^2 번 수행하므로 제한 시간 내에 풀이할 수 없다.

따라서 동적 계획법을 사용해 LIS를 구한다.

LIS를 구하는 시간 복잡도는 다음 두가지 경우이다

- N^2
- NlogN

이 중에서 NlogN의 방법을 사용한다.

### 공간 복잡도

수의 범위가 전부 1,000,000 이내 이므로 int형으로 선언한다.

### NlogN의 방법

LIS를 직접 구하는 경우 NlogN의 방법으로 구할 수 있다.

LIS를 유지하기 위한 최적의 위치에다가 수를 삽입하는 방식으로 LIS를 생성한다.

이 때 최적의 위치를 검색 하기 위해 이분 탐색을 이용하며

N개의 수를 입력받으며 각 경우 이분탐색을 수행하므로 시간복잡도는 NlogN이다.

```cpp
vector<int> lis;
// 아래 lis.back() 비교를 위해 제일 작은 수를 넣어줌
lis.push_back(-1);

for (int i = 0; i < N; i++) {
  // i번째 수열의 값을 입력받음
  cin >> temp;

  // 증가하는 수열의 경우
  if (lis.back() < temp) {
    lis.push_back(temp);
  } else {
    // loswer_bound로 현재 수보다 큰 값이 나오는 위치를 반환함
    auto it = lower_bound(lis.begin(), lis.end(), temp);
    *it = temp;
  }
}

answer = lis.size() - 1;
```

## 정리

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|     156      |       56       |

## 고생한 점
