# 18870. 좌표 압축

[링크](https://www.acmicpc.net/problem/18870)

|  난이도   | 정답률(\_%) |
| :-------: | :---------: |
| Silver II |   69.204    |

## 설계

### 시간복잡도

좌표 압축의 기본은 정렬 후 중복을 제거하는 것이다.

정렬 후에 압축된 좌표를 찾는 방법은 두가지가 존재한다.

1. map을 이용해 압축된 좌표의 table을 생성
2. lower_bound를 이용해 index 검색

N은 최대 1,000,000 이며 각 값의 범위는 -1e9 ~ 1e9 이다.

정렬시 N^2의 시간이 걸릴 경우 제한시간 2초 내에 통과할 수 없다. 따라서 NlogN의 정렬 방법을 이용해야한다.

정렬 & 중복제거가 된 좌표에서 map을 이용해 테이블을 생성시에 각 숫자에 해당하는 정보를 찾을 때 logN의 시간복잡도가 발생한다.

lower_bound를 사용할 때도 이분탐색을 수행하므로 logN의 시간복잡도가 발생한다. 하지만 map을 생성하지 않아도 되므로 좀더 유리하다.

따라서 문제에서 주어진 시간 복잡도는 NlogN + NlogN = 2NlogN 이고 이는 제한 시간인 2초 내에 풀 수 있다.

### 정렬

예시로 주어진 데이터

```cpp
2 4 -10 4 -9
```

를 정렬 & 중복제거 하는 경우 아래와 같이 된다.

```cpp
-10 -9 2 4
```

이 때 각 숫자를 index에 대한 table로 생각할 경우

```cpp
2 4 -10 4 -9 // 아래와 같이 변함
2 3 0 3 1
```

이는 2차원 좌표에도 동일하게 적용 가능하다.

```cpp
data = {{0, 0}, {1, 1}, {0, 2}, {2, 0}, {0, 3}, {3, 2}, {1, 4}, {4, 4}, {100, 50}, {150, 30}}
// 위와 같은 2차원 좌표를 압축하면

0 0 = 0 0
1 1 = 1 1
0 2 = 0 2
2 0 = 2 0
0 3 = 0 3
3 2 = 3 2
1 4 = 1 4
4 4 = 4 4
100 50 = 5 6
150 30 = 6 5
```

좌표 압축후에는 순서만 중요하기 때문에, 각 좌표마다 독립된 순서만 지니고있으면 된다.

## 정리

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|     472      |                |

## 고생한 점
