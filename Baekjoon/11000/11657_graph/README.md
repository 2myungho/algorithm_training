# 11657. 타임머신

[링크](https://www.acmicpc.net/problem/11657)

| 난이도  | 정답률(\_%) |
| :-----: | :---------: |
| Gold IV |   30.667    |

## 설계

### 시간 복잡도

벨만 포드 알고리즘을 이용해 시작점에서 나머지 거리 까지의 최단 경로를 구한다.

벨만 포드 알고리즘의 경우 시간 복잡도는 O(VE) 이다. (각 정점마다 연결 노드를 모두 탐색한다)

시간복잡도는

```cpp
N * M = 500 * 6,000 = 3,000,000
```

이므로 제한시간 내에 충분하다.

### 공간 복잡도

가중치를 갱신할 때 최악의 경우 10,000의 이동거리를 모든 버스 경로, 모든 도시 500개 만큼 더할 수있다.

따라서 최악의 경우의 가중치는 30,000,000,000 이므로 int형의 범위를 벗어난다.

따라서 각 가중치들의 합을 저장하는 배열의 data는 long long 형으로 생성한다.

### 벨만 포드 알고리즘

최단거리를 구하는 것을, 한 점에서만 하는것이 아니라 모든 점에서 한번씩 수행한다.

이 때 최단경로를 갱신할 때, 자기 자신으로 돌아오는 경우 음의 사이클이 발생했으므로, 이를 체크한다.

```cpp
// initialize
for (int i = 1; i <= N; i++) {
  costs[i] = INF;
}

costs[start] = 0;
bool isCycle = false;

// 모든 점에서
for (int i = 1; i <= N; i++) {
  // 연결된 다른 모든 점으로 이동하는것을 계산
  for (int j = 1; j <= N; j++) {
    for (edge g : graph[j]) {
      if (costs[j] != INF && costs[g.end] > g.cost + costs[j]) {
        costs[g.end] = g.cost + costs[j];

        if (i == N) isCycle = true;
      }
    }
  }
}
```

## 정리

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|      8       |       0        |

## 고생한 점

더한 값을 비교할 때 int형을 초과할 수 있다. 이 경우를 대비해 long long형으로 구조를 변경함.

int형을 초과한 경우 음의 싸이클이 생겨 출력 초과가 발생하게됨.
