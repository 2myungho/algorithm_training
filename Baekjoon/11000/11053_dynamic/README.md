# 11053. 가장 긴 증가하는 부분 수열

[링크](https://www.acmicpc.net/problem/11053)

|  난이도   | 정답률(\_%) |
| :-------: | :---------: |
| Silver II |   36.981    |

## 설계

### 시간 복잡도

수열의 크기가 최대 1,000 이다.

모든 경우를 탐색하는 경우 1,000^2 번 수행하므로 제한 시간 내에 충분히 풀이할 수 있다.

동적 계획법을 사용하는 경우 LIS 를 구하면 된다.

LIS를 구하는 시간 복잡도는 다음 두가지 경우이다

- N^2
- NlogN

### 공간 복잡도

수의 범위가 전부 1,000 이내 이므로 int형으로 선언한다.

### 동적 계획법

dp를 다음과 같이 정의한다.

```cpp
int dp[i] // i번째 수를 마지막 원소로 가지는 LIS의 길이
```

초기값은 다음과 같다.

```cpp
// 모든 원소에 대해 자기 자신을 가진 수열을 생성 가능하므로
// 길이 1인 수열을 만들 수 있다.
dp[] = 1;
```

i를 0부터 N까지 순회하며 dp를 차례대로 (0번째 부터) 채워나간다.

현재 dp를 구할 때 이전의 dp를 이용해 구할 수 있다.

현재 arr[i]의 수가 arr[j] 보다 크고, j까지 LIS가 i까지 LIS보다 큰 경우

j까지 포함한 LIS에 i를 추가하면 가장 큰 LIS를 만들 수 있다.

```cpp
for (int i = 0; i < N; i++) {
  for (int j = 0; j < i; j++) {
    if (arr[i] > arr[j] && dp[i] < dp[j] + 1) {
      dp[i] = dp[j] + 1;
    }
  }
}
```

### NlogN의 방법

LIS를 직접 구하는 경우 NlogN의 방법으로 구할 수 있다.

LIS를 유지하기 위한 최적의 위치에다가 수를 삽입하는 방식으로 LIS를 생성한다.

이 때 최적의 위치를 검색 하기 위해 이분 탐색을 이용하며

N개의 수를 입력받으며 각 경우 이분탐색을 수행하므로 시간복잡도는 NlogN이다.

```cpp
vector<int> lis;
// 아래 lis.back() 비교를 위해 제일 작은 수를 넣어줌
lis.push_back(-1);

for (int i = 0; i < N; i++) {
  // i번째 수열의 값을 입력받음
  cin >> temp;

  // 증가하는 수열의 경우
  if (lis.back() < temp) {
    lis.push_back(temp);
  } else {
    // loswer_bound로 현재 수보다 큰 값이 나오는 위치를 반환함
    auto it = lower_bound(lis.begin(), lis.end(), temp);
    *it = temp;
  }
}

answer = lis.size() - 1;
```

## 정리

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|      0       |       0        |

## 고생한 점
