# 2294. 동전 2

[링크](https://www.acmicpc.net/problem/2294)

|  난이도  | 정답률(\_%) |
| :------: | :---------: |
| Silver I |   28.024    |

## 설계

### 시간 복잡도

모든 경우를 수행하는 경우, 동전의 최대 갯수는 100 이므로 2^100 개의 경우를 시도해야 한다.

이는 제한시간 1초 내에 불가능하다.

따라서 동적 계획법을 이용해 풀이한다.

### 공간 복잡도

동전의 가치는 최대 100,000 이며 최대 갯수는 100개이다.

K는 10,000 이하이다.

따라서 동전들로 구성할 수 있는 최대 가치는 10,000,000 이며 이는 int형으로 충분하다.

### 동적 계획법

각 동전과 value에 따른 dp를 다음과 같이 생성한다.

현재 선택할 수 있는 동전의 종류의 갯수와 만들고자 하는 가치가 다음과 같을 때 최소의 동전 수

```cpp
int dp[만들고자 하는 가치] // value : 최소 동전 개수;

// 동전의 갯수는 100까지, 가치의 범위는 10000 까지
int dp[10001];
```

dp의 일반 식은 다음과 같이 설정하자.

```cpp
dp[j] = min(dp[j], dp[j - coin[i] + 1]); // j - coin[i]에서 coin[i]를 더해 만드는 동전의 개수
```

그리고 dp의 초기값을 설정해야 한다.

최소값을 찾는 문제이므로 최악의 경우 동전의 개수를 초기값으로 설정한다. (10001)

fill 함수를 이용해 배열을 채울 수 있다.

```cpp
// dp[][] = 10,000
fill(&dp[0], &dp[10001], 10001);
```

### down-top 방식

동적 계획법을 정의했으므로 값을 채워나간다.

```cpp
for (int i = 1; i <= N; i++) {
  cin >> coins[i];

  for (int j = coins[i]; j <= K; j++) {
    dp[j] = min(dp[j], dp[j - coins[i]] + 1);
  }
}
```

### fill을 이용한 다차원 배열 초기화

memset을 이용한 경우 0으로 초기화는 가능하지만, 특정 값으로 2차원 이상의 배열을 초기화 하기는 어렵다.

따라서 fill을 이용해 초기화한다.

```cpp
#define ROW 10
#define COL 20

int arr[ROW][COL];

// 전체 초기화 : 처음에는 [0][0]을 써주고, 그 다음 칸에는 [최대 행(값) - 1][최대 열], 다음 칸에는 초기 상태의 값
fill(&arr[0][0], &arr[ROW - 1][COL], value);
```

### index 범위 처리

입력받는 동전의 가치가 dp 배열의 index를 초과할 수 있다.

이는 각 동전의 가치가 K를 초과할 수 있기 때문이다.

따라서 초기값을 설정할 때 주의해야 한다.

```cpp
cin >> coins[i];

if (coins[i] < 10001) {
  dp[i][coins[i]] = 1;
}
```

## 정리

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|      4       |       0        |

## 고생한 점
