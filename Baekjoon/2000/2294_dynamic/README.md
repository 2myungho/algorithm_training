# 2294. 동전 2

[링크](https://www.acmicpc.net/problem/2294)

|  난이도  | 정답률(\_%) |
| :------: | :---------: |
| Silver I |   28.024    |

## 설계

### 시간 복잡도

모든 경우를 수행하는 경우, 동전의 최대 갯수는 100 이므로 2^100 개의 경우를 시도해야 한다.

이는 제한시간 1초 내에 불가능하다.

따라서 동적 계획법을 이용해 풀이한다.

### 공간 복잡도

동전의 가치는 최대 100,000 이며 최대 갯수는 100개이다.

K는 10,000 이하이다.

따라서 동전들로 구성할 수 있는 최대 가치는 10,000,000 이며 이는 int형으로 충분하다.

### 동적 계획법

각 동전과 value에 따른 dp를 다음과 같이 생성한다.

현재 선택할 수 있는 동전의 종류의 갯수와 만들고자 하는 가치가 다음과 같을 때 최소의 동전 수

```cpp
int dp[동전의 종류 갯수][만들고자 하는 가치] // value : 최소 동전 개수;

// 동전의 갯수는 100까지, 가치의 범위는 10000 까지
int dp[101][10001];
```

dp의 일반 식은 다음과 같이 설정하자.

```cpp
dp[i][k] = min(dp[i-1][k], dp[i][K-k] + 1);
```

그리고 dp의 초기값을 설정해야 한다.

최소값을 찾는 문제이므로 최악의 경우 동전의 개수를 초기값으로 설정한다.

최악의 경우는 K가 최대 값이고 동전의 가치가 최소 일 때 이므로

K = 10,000, coin = 1

따라서 총 10,000 개의 동전을 사용할 때이다.

```cpp
// dp[][] = 10,000
fill(&dp[0][0], &dp[100][10001], 10000);
```

또한 각 동전에 해당하는 가치를 만들 때는 각각의 동전 1개로 만들 수 있으므로 이를 설정한다.

```cpp
for (int i = 1; i <= N; i++) {
  // 범위 검사 필요
  if (coins[i] < 10001) {
    dp[i][coins[i]] = 1;
  }
}
```

### down-top 방식

동적 계획법을 정의했으므로 값을 채워나간다.

```cpp
// dp[i][k]
for (int i = 1; i < coins.size(); i++) {
  coin = coins[i];
  for (int k = 1; k <= K; k++) {
    // 만약 현재 만드려는 가치의 이전 단계가 범위를 초과하는 경우
    if (k - coin < 0) {
      dp[i][k] = min(dp[i][k], dp[i - 1][k]);
      continue;
    }

    dp[i][k] = min(dp[i][k], min(dp[i - 1][k], dp[i][k - coin] + 1));
  }
}
```

### fill을 이용한 다차원 배열 초기화

memset을 이용한 경우 0으로 초기화는 가능하지만, 특정 값으로 2차원 이상의 배열을 초기화 하기는 어렵다.

따라서 fill을 이용해 초기화한다.

```cpp
#define ROW 10
#define COL 20

int arr[ROW][COL];

// 전체 초기화 : 처음에는 [0][0]을 써주고, 그 다음 칸에는 [최대 행(값) - 1][최대 열], 다음 칸에는 초기 상태의 값
fill(&arr[0][0], &arr[ROW - 1][COL], value);
```

### index 범위 처리

입력받는 동전의 가치가 dp 배열의 index를 초과할 수 있다.

이는 각 동전의 가치가 K를 초과할 수 있기 때문이다.

따라서 초기값을 설정할 때 주의해야 한다.

```cpp
cin >> coins[i];

if (coins[i] < 10001) {
  dp[i][coins[i]] = 1;
}
```

## 정리

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|      4       |       0        |

## 고생한 점
