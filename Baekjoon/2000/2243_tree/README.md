# 2243. 사탕상자

[링크](https://www.acmicpc.net/problem/2243)

|   난이도   | 정답률(\_%) |
| :--------: | :---------: |
| Platinum V |   37.935    |

## 설계

### 세그먼트 트리

A 배열의 부분 합을 구할 때 A 배열이 계속해서 바뀔 수 있다고 할때,
부분 합을 트리구조에 저장한다.

O(logN)의 속도로 A 배열의 부분 합을 빠르게 구할 수 있게 한다.

![이미지링크](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d1/Segment_tree.svg/420px-Segment_tree.svg.png)

### 세그먼트 트리 (사탕상자)

사탕의 종류(맛의 종류)가 1000000가지 이므로
리프 노드가 100만개인 세그먼트 트리를 생성한다.

target 번째로 맛있는 사탕을 찾는 문제임에 유의하자.

만약 1번 사탕이 3개, 2번 사탕이 3개 존재하는 경우

{1, 1, 1, 2, 2, 2}

이때 3번째 사탕은 1이다.

1. update 함수는 기존의 세그먼트 트리와 같다.
2. 각 맛에 해당하는 사탕의 수는 단말 노드에 존재한다. (단말노드로 접근)
3. 현재 노드의 사탕 수에 따라 next가 달라진다.
   - 왼쪽 노드 : 왼쪽 자식의 누적합이 target개 이상
   - 오른쪽 노드: 왼쪽 자식의 누적합이 target개 미만이
   - 오른쪽 노드로 이동시 (K - 왼쪽 자식의 누적합)번째 사탕을 꺼낸다.

탐색의 식

```cpp
tree[node * 2] >= target
```

tree[node X 2] 부분에 사탕의 수가 target개 보다 많아야 target번째 수를 찾을 수 있다는 것이다.

## 정리

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|      64      |       32       |

## 고생한 점
