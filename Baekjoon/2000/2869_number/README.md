# 2869. 달팽이는 올라가고 싶다

[링크](https://www.acmicpc.net/problem/2869)

|  난이도   | 정답률(\_%) |
| :-------: | :---------: |
| Bronze II |   26.888    |

## 설계

### 시간복잡도

높이 V, 올라가는 길이 A, 떨어지는 길이 B의 범위는 최대 1,000,000,000까지입니다.

1,000,000,000는 int형의 범위 내이기 때문에 변수를 전부 int로 선언해도 되겠습니다.

문제의 풀이 방법은 2가지가 존재하겠습니다.

1. 올라가고, 내려가는것을 simulation으로 풀이
2. 나누기 연산의 몫을 이용

1번 방법의 경우 하루에 A길이 만큼 올라가고 B 길이만큼 떨어지는 것을 반복합니다.

코드의 구조는 대략 다음과 같겠습니다.

```cpp
while(true){
  height += A;
  if(height >= V){
    break;
  }
  height -= B;
}
```

이 경우 A가 매우 작고, V가 매우 큰 경우 매우 많은 연산이 걸립니다.

예를들어 A=2이고 B=1, V=1,000,000,000 일 때를 살펴봅시다.

하루에 올라갈 수 있는 거리는 A-B 만큼 입니다. 대략 V / (A - B)번 만큼 연산을 수행하므로 총 1,000,000,000 번 만큼 연산을 수행합니다.
이는 대략 18분 정도 시간이 소요됩니다.

문제의 시간제한은 0.15초이므로 이 방법으로는 시간 안에 풀이가 불가능합니다.

따라서 시간복잡도를 줄일 필요가 있습니다.

### 올라가고 내려가고

2번 방법의 경우 나누기 연산을 수행하면 되기 때문에 시간 복잡도는 O(1) 입니다.

그러나 정답은 V / (A - B)이 아닙니다. 하루에 올라가는 길이 A가 매우 큰 경우 떨어지기 전에 V에 먼저 도달하는것이 가능하기 때문입니다.

주어진 test case를 살펴봅시다

```sh
A=2, B=1, V=5

1일 차 +2 -1 = 1
2일 차 +2 -1 = 2
3일 차 +2 -1 = 3
4일 차 +2 (도달)

정답 4
```

V / (A - B) = 5이지만, 실제 정답은 4임을 알 수 있습니다. 따라서 지금 위치에서 올라갔을 때 목표에 도달할 수 있는지를 판단해야 합니다.
위 케이스에서 3일차에 최종적으로 도달한 높이를 눈여겨봅시다.

A, B, V를 입력받았을 때, 최소 V-A 만큼 도달한 경우 한번만 더 올라가면 목표에 도달하는것이 보장됩니다.

즉 하루가 끝났을 때 높이가 V-A보다 큰 경우, 다음날엔 무조건 V에 도달합니다.

최소 (V-A)에 도달하기 위해선 한번에 (A-B) 만큼 올라가기 때문에 (V-A) / (A-B) 일이 걸립니다.

이 때, 정수의 나누기 연산에서 나머지를 무시하므로, 나누어 떨어지지 않는 경우를 고려해야 합니다.

예를들어 (V-A) 높이에 도달하는데 5.5일이 걸린다고 한다면, 이는 최소 6일의 시간이 존재하면 V-A이상 높이에 도달할 수 있습니다.

현재 목표는 V-A 이상 높이에 도달하는것이 목표이므로, 나누어 떨어지지 않는 경우는 +1을 수행합니다.

그러면 +1을 수행했을 때 V-A 이상이면, V도 가능하지 않을까요??

(V-A) / (A-B) + 1 이 V보다 작다는 것은 수식으로 증명이 가능합니다.

```sh
(V-A) / (A-B) + 1 < V
V-A < V * ((A-B) + 1)

여기서 A>B 이므로 항상 오른쪽이 큼이 보장됨
```

마지막으로 현재 위치에서 A 만큼 올라가면 목표에 도달하기 때문에 현재 일수 1일을 더하면 정답입니다.

## 정리

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|      0       |       0        |

## 고생한 점
