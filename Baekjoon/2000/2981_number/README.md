# 2981. 검문

[링크](https://www.acmicpc.net/problem/2981)

|  난이도  | 정답률(\_%) |
| :------: | :---------: |
| Silver I |   21.075    |

## 설계

### 시간복잡도

N은 최대 100 까지이며, 입력되는 수의 최대 값은 1,000,000,000 까지이다.

풀이 방법으로는 다음 두 가지를 생각해 볼 수 있다.

1. 2부터 2번째로 작은 수 까지 brute force
2. gcd를 이용한 방법

1번 방법의 경우 나머지의 가능한 범위는 0부터 (두번째로 작은 값 - 1)인 성질을 이용하는 방법이다.

이는 아래의 예시를 보면 알 수 있다.

```sh
2
6
20

2 7 14
```

그러나 이 방법을 사용하면, 두번째로 작은 수가 1,000,000,000일 경우 최대 대략 1,000,000,000번 brute force를 수행해야하고 이는 시간제한 1초내에 불가능하다.

2번 방법 gcd를 이용한 경우는 다음과 같다.

```cpp
a, b, c // 세개의 수가 주어진다.

// 각각의 수를 x로 나눈 나머지가 z라고 할 때 다음과 같다.
a % x = z
b % x = z
c % x = z

// 이를 뒤집어 생각하면 c-z, b-z, a-z 의 최대 공약수가 존재 한다는 의미이다.
(a-z) % x = 0
(b-z) % x = 0
(c-z) % x = 0

// 이 경우 a, b, c를 다음과 같이 나타낼 수 있다. (n_x는 임의의 상수이다.)
a = x * n_1 + z;
b = x * n_2 + z;
c = x * n_3 + z;

// 상수 z를 제거하기 위해 빼면 다음과 같다.
b - a = x * (n_2 - n_1)
c - a = x * (n_3 - n_1)

// 여기서 b-a와 c-a의 최대 공약수 X를 구하면 다음과 같다.
X = gcd(b-a, c-a) = x * n_x
// n_x는 (n_2 - n_1) 과 (n_3 - n_1) 의 최대 공약수이다.
```

X는 a, b, c의 최대 공약수 이므로,
이 X의 약수들로 a, b, c의 나머지를 구할 경우, 이 나머지들은 모두 같다.

따라서 1을 제외한 X의 약수들이 정답이 된다.

## 정리

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|      0       |       0        |

## 고생한 점
