# 2636. 치즈

[링크](https://www.acmicpc.net/problem/2636)

| 난이도 | 정답률(\_%) |
| :----: | :---------: |
| Gold V |   49.346    |

## 설계

### 시간 복잡도

치즈 판의 크기는 최대 100^2 이다.

겉면에 있는 치즈부터 녹으며, 모든 테두리에는 치즈가 포함되어있지 않다.

하루에 BFS, DFS로 녹아야 할 판의 갯수는 최악 100^2 개 이다.

한번 훑을 때 마다 상, 하, 좌, 우 4번을 비교한다.

따라서 겉면을 훑는 경우 들어가는 시간 복잡도는

```cpp
100*100*4
```

치즈는 겉면부터 녹으므로 아무리 두꺼운 치즈라도 50일이 지나면 모두 녹는다.

따라서 시간 복잡도는

```cpp
O(2,000,000)
```

이며 제한시간 1초 내에 충분하다.

### 공간 복잡도

치즈의 여부를 나타낼 2차원 배열 100^2이 필요하다.

이 배열에는 다음 두가지 자료가 들어간다.

- 치즈
- 빈공간

또한 녹아야 할 치즈를 판별하는 2차원 visited 배열이 필요하다

### 탐색

모든 테두리의 겉면은 치즈가 놓여있지 않음이 보장된다.

따라서 (0,0) 부터 bfs로 탐색을 수행한다.

이 때 이미 탐색한 부분은 다시 탐색하면 안되므로 visited 배열을 이용한다.

하루 마다 다음 일들이 일어난다.

```cpp
// visited 배열을 초기화한다.
memset(visited, 0, sizeof(visited));
// 시작점을 설정
q.push({0, 0});

while (!q.empty()) {
  Axis cur = q.front();
  q.pop();

  for (Axis dir : dirs) {
    Axis next = cur;
    next.y += dir.y;
    next.x += dir.x;

    // 이미 탐색한 좌표거나 유효하지 않은 좌표인 경우 건너뜀

    visited[next.y][next.x] = 1;

    // 빈 공간이 경우와, 녹아야 할 치즈인 경우 분기처리
    if (!map[next.y][next.x]) {
      q.push(next);
    } else {
      melts.push(next);
    }
  }
}
```

녹일 치즈들을 저장해놓고, 크기에 따라 다르게 동작한다.

```cpp
// 녹을 치즈가 없으면 더이상 탐색하지 않음
if (melts.empty()) {
  break;
}

// 직전에 녹을 치즈 사이즈를 구성
answer = melts.size();

// 치즈를 녹임
while (!melts.empty()) {
  Axis cur = melts.front();
  melts.pop();
  map[cur.y][cur.x] = 0;
}

day += 1;
```

### array를 이용

단순 배열의 경우에는 vector 클래스 보다는 array를 사용하는 편이 더 효율적이다.

```cpp
array<int, 5> myArray { 7, 3, 1, 9, 5 };

// 만약 구조체를 넣는 경우
struct Axis {
  int y, x;
};
array<Axis, 4> dirs = {{{-1, 0}, {0, 1}, {1, 0}, {0, -1}}}; // 괄호를 한번 더 감싸준다.
```

## 정리

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|      0       |       0        |

## 고생한 점
