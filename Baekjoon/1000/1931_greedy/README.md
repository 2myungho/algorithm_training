# 1931. 회의실배정

[링크](https://www.acmicpc.net/problem/1931)

|  난이도   | 정답률(\_%) |
| :-------: | :---------: |
| Silver II |   28.395    |

## 설계

### 시간복잡도

N은 최대 100,000까지 이다. 제한 시간은 1초 이내이므로 O(NlogN) 이내에 문제를 해결해야 한다.

풀이 방법은 대략 2가지 이다.

- 모든 경우를 시도해봄
- 그리디 알고리즘을 이용

브루트포스 방법의 경우 N이 너무 크고 N^2번 이상 소요되므로 시간 내에 해결하지 못한다.

그리디 알고리즘을 이용하는 경우 각 경우마다 최선의 해를 선택하기 때문에 각 요소에 대하여 N번 순회하며 해를 구하면 된다.

이 경우 한번의 순회를 진행하기 위해 정렬을 한번 수행해주어야 한다. 정렬은 최소 NlogN 의 연산이 소요된다.

따라서 그리디 알고리즘을 이용하는 경우 NlogN번 만에 풀이할 수 있다.

### 그리디 알고리즘

접근법은 3가지가 존재한다.

- 가장 먼저 시작하는 것부터
- 회의실을 빌리는 시간이 가장 짧은 것부터
- 가장 먼저 끝나는 것부터

1번 방법의 경우 다음의 반례가 존재한다.

```cpp
1 10  // 가장 먼저 시작하는 회의를 고르면 count = 1이다
2 4   // 그러나 아래 경우를 순차적으로 선택하면 count = 3이다.
5 7
8 11
```

2번 방법의 경우 다음의 반례가 존재한다.

```cpp
1 6
5 8   // 회의 시간이 가장 짧은 이 경우를 고를 경우 count = 1이다.
7 11  // 1번 3번 회의를 고르는 경우 count = 3이다.
```

3번 방법의 경우 정 해이다.

회의가 일찍 끝나는 기준을 잡으면, 회의를 선택할 수 있는 범위가 넓어진다.

일찍 끝나면 더 회의를 많이 진행할 수 있기 때문이다.

만약 1번째 회의가 2번째 회의보다 빨리 끝나는 경우를 생각해보자.

2번째 회의가 끝나는 시점에서, 1번 회의를 선택했을 때와 2번 회의를 선택했을 때 선택할 수 있는 회의의 경우의 수는 같다.

```cpp
1 3
2 5
6 8
9 11
...
```

즉 위 경우는 맨 처음 회의를 1번이나 2번을 선택하나 count의 수는 같을것이다.

그러나 1번 회의를 선택하면 2번 회의가 끝나기 전까지 회의를 선택할 수 있는 가능성이 더 많아진다.

따라서 먼저 끝나는 회의를 선택하는 것이 더 많은 가능성을 갖고 있으므로 count가 더 클 가능성이 높아진다.

이를 N번 회의까지 반복할 경우, 결국은 먼저 끝나는 회의를 선택하는 것이 더 유리함을 알 수 있다.

### 순회

먼저 끝나는 순으로 정렬한 경우 0번째 index부터 끝까지 순회하므로 총 N번만 순회하면 된다.

index를 증가시키며 현재 회의의 끝나는 시간을 갱신하고, 이에대해 분기처리한다.

```cpp
for (int i = 0; i < N; i++) {
  if (rooms[i].start >= end) {
    end = rooms[i].end;
    count += 1;
  }
}
```

## 정리

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|      28      |       8        |

## 고생한 점

while문을 이용한 경우 시간초과가 발생했다.

순회를 N번 수행하는 것이 아닌 while문으로 수행한 경우 다음 경우를 고려해야 한다.

- 회의의 시작과 끝이 같은 경우

이 경우 end만 갱신하면 무한 루프에 빠지게 된다.

따라서 while문으로 구현할 경우 check배열 또한 만들어야하고 구현이 복잡해짐.

```cpp
room[i].end == room[j].start
```

문제 조건에서 이전 회의가 끝나자마다 다음 회의가 가능한경우의 처리를 하기 위해 비교 연산에 등호를 추가해야 한다.
