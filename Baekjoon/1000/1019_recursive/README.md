# 1019. 책 페이지

[링크](https://www.acmicpc.net/problem/1019)

| 난이도 | 정답률(\_%) |
| :----: | :---------: |
| Gold I |   36.547    |

## 설계

### 시간 복잡도

N은 최대 1,000,000,000 까지이므로 N번 순회해서는 제한 시간 2초 내에 풀이가 불가능하다.

따라서 브루트 포스 방법으로는 불가능하다.

이 문제를 풀이하기 위해 자리수 별로 분할해 문제를 풀이한다.

N의 자리수를 X라고 하자. 10^X ~ 10^(X+1) 사이에 N이 위치할것이다.

자리 수를 1의 자리부터 X 자리 까지 증가시켜가며 채울 수 있는 자리수를 검사 한다면 시간복잡도는 다음과 같다.

```cpp
// X의 최대 값 10 * 끝 자리 수를 맞추는 연산의 최대 경우
10 * 20
```

따라서 O(200) 이내이므로 시간 내에 풀이가 충분하다.

### 공간복잡도

수의 범위는 10^9 까지 이므로 int형으로 선언해도 충분하다.

### 부분별로 나눠 생각하기

이 문제를 조금 변형해 start 부터 end까지 더한다고 가정하자.

만약 10 단위로 끊어서 생각한다고 했을 때, start가 10 미만이라면 앞에 붙는 0을 처리해줘야 한다.

이를 처리하기 위해 0을 처리하지 않아도 되는 최소 수 까지 start를 증가시킨다.

이 경우 start는 0으로 끝나는 단위가 될 것이다.

또한 end도 끝자리가 9가 되도록 감소시킨다.

이렇게 증가하고 감소시킨 수들은 자리수를 분해해 정답 배열에 counting 한다.

이 경우 0~9까지 (10단위) 로 문제를 잘라 생각할 수 있고, 정답 배열에 각 자리수를 counting 한다.

이렇게 나올 수 있는 모든 1의 자리의 경우를 counting 할 수 있다.

```cpp
for(int i=0;i<10;i++){
  answers[i] += (end / 10) - (start / 10) + 1
}
```

이제 이를 단위를 증가시키며 10의자리, 100의자리 ... X자리 만큼 count한다.

### 재귀

단위를 증가시킬 때마다 이전에 계산한 자리 수는 더이상 계산하지 않아도 되므로 start, end는 다음과 같이 변한다.

```cpp
start /= 10;
end /= 10;
```

자리 수는 10씩 증가한다.

```cpp
digits *= 10;
```

그리고 start는 증가하고, end는 감소하므로 start가 end보다 커지는 경우가 생기는데, 이 경우 더이상 탐색을 중지한다.

따라서 식은 다음과 같다.

```cpp
void recur(int start, int end, int digits) {
  while (start % 10 != 0 && start <= end) {
    counting(start, digits);
    start++;
  }

  if (start > end) return;
  while (end % 10 != 9 && end >= start) {
    counting(end, digits);
    end--;
  }

  int diff = (end / 10 - start / 10 + 1);
  addAll(diff * digits);

  recur(start / 10, end / 10, digits * 10);
}
```

## 정리

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|      0       |       0        |

## 고생한 점
