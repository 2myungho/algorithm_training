# 1405. 미친 로봇

[링크](https://www.acmicpc.net/problem/1405)

| 난이도 | 정답률(\_%) |
| :----: | :---------: |
| Gold V |   32.520    |

## 설계

### 시간 복잡도

N이 최대의 수 일때 모든 경우를 탐색하는 경우는 4^14 = 268,435,456‬ 으로 제한시간 1초 내에 불가능하다.

### 공간 복잡도

이미 방문 여부를 판단하기 위해 도달했는지 나타내는 2차원 배열과 중복 여부 2차원 배열을 만든다.

현재 상황에서 탐색을 반복했을 때, 제일 마지막에 도달한 위치가 중복될 수 있음에 유의한다.

### backtracking

현재 좌표에 도달 시 방문 여부를 체크한다.

현재 위치에서 동, 서, 남, 북을 탐색한다.

이 때, 이전에 방문한 위치의 경우 탐색하지 않고 건너뛴다.

시작 위치에서 동쪽, 서쪽으로 탐색하는 경우 결국 같은 위치에 도달할 수 있다. 그러나 이 경우는 중복이 아니다. (끝 위치에 도달했으므로)

다음 좌표로 탐색을 이어나갈 때 마다, 그때까지의 확률을 갱신해서 넘긴다.

```cpp
void dfs(int index, Axis cur, double val) {
  if (index == N) {
    answer += val;
    return;
  }

  visited[cur.y][cur.x] = true;
  for (int i = 0; i < 4; i++) {
    Axis next = cur;
    next.y += dirs[i].y;
    next.x += dirs[i].x;

    if (visited[next.y][next.x]) continue;

    dfs(index + 1, next, val * percents[i]);
  }
  visited[cur.y][cur.x] = false;
}
```

## 정리

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|      28      |       12       |

## 고생한 점

예제 케이스의 경우 다음과 같이 도달한다.

```cpp
00100
02020
10001
02020
00100
```

각 좌표에 적힌 숫자는 끝까지 도달했을 때의 count이다.

이 경우에 중복을 제거하는 것으로 문제를 잘못 판단했다.
