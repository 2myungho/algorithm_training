# 1654. 랜선 자르기

[링크](https://www.acmicpc.net/problem/1654)

|   난이도   | 정답률(\_%) |
| :--------: | :---------: |
| Silver III | Silver III  |

## 설계

### 시간복잡도

랜선의 길이는 2^31-1보다 작거나 같은 자연수이다.

자를 길이의 범위는 1 ~ 2^31-1 이므로 이를 모두 할 경우 시간복잡도는 O(2^31-1) 이며 이는 제한시간 2초 내에 불가능하다.

문제의 풀이 방법은 다음과 같다

- 이분탐색

이분 탐색을 이용하는 경우 탐색은 최대 log(2^31-1) 번 만큼 수행하면 되며, 이는 최대 32번 까지이다.

자른 랜선의 갯수를 세는 것은 랜선의 갯수만큼 반복하므로 최대 10,000번 까지이다.

따라서 최악의 경우 O(32,000) 번 만큼 수행한다. 이는 제한시간 내에 충분하다.

### 공간복잡도

랜선의 갯수 K는 10,000 이하의 자연수이고, N의 범위가 2^31-1까지이므로 최악의 경우 1로 자른다고 했을 때 (10,000)(2^31-1) 개의 랜선을 만들 수 있다.

이는 int형의 범위를 초과하므로 랜선의 갯수를 셀 때는 long long 형으로 선언해야한다.

최대 long long을 이용하므로 자료형은 long long을 이용한다.

### 풀이

이분탐색을 이용해 자를 랜선의 길이를 정한다.

이 때 count가 N이상인지로 분기처리한다.

- count >= N : min 갱신
- count < N : max 갱신

```cpp
while (min_wire + 1 < max_wire) {
  long long mid = (min_wire + max_wire) / 2;
  long long count = 0;

  // do something...

  if (count >= N) {
    min_wire = mid;
  } else {
    max_wire = mid;
  }
}
```

## 정리

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|      4       |       0        |

## 고생한 점

자료의 범위를 int형으로 했을 때 stack_overflow가 발생했다.

long long으로 변환했어야함
