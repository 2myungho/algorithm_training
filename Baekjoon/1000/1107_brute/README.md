# 1107. 리모컨

[링크](https://www.acmicpc.net/problem/1107)

| 난이도 | 정답률(\_%) |
| :----: | :---------: |
| Gold V |   22.179    |

## 설계

### 시간 복잡도

N은 500,000 이하의 정수이다. 버튼을 누르는 방법은 다음과 같다.

- N과 같은 자릿수의 채널에서 +, - 버튼을 누름
- N보다 자릿수가 하나 작은 채널에서 +, - 버튼을 누름
- N보다 자릿수가 하나 큰 채널에서 +, - 버튼을 누름

가능한 모든 채널을 검사 할 경우 N보다 자릿수가 하나 큰 경우까지 생각해야 하므로
1 ~ 1,000,000 까지 검사해야 한다.

이는 대략 1초정도 소요되고, 제한시간 2초 안에 충분하다.

### 브루트 포스

가능한 모든 경우를 수행하는 방법은 다음과 같다.

- 1 ~ 1,000,000 까지 전부 검사
- dfs를 이용해 유효한 채널 탐색 후 검사

첫번째 방법의 경우 만들 수 없는 채널의 경우도 검사해야 하므로 시간복잡도가 늘어난다.

채널의 유효성 검사는 다음과 같이 수행한다.

```cpp
bool isError(int i) {
  string num = to_string(i);

  for (char c : num) {
    if (check[c - '0']) return true;
  }
  return false;
}
```

두번째 방법의 경우 백트래킹으로 유효하지 않은 채널은 건너뛸 수 있다.

dfs의 구조는 다음과 같이 선언한다.

```cpp
// 탐색 깊이, 생성한 숫자, 버튼누른 횟수, 탐색을 끝낼 깊이
void dfs(int depth, int num, int count, int limit) {
  if (depth > 0) {
    answer = min(answer, abs(target - num) + count);
  }

  if (depth >= limit) {
    return;
  }
}
```

여기서 depth가 0 이상일 때만 answer를 갱신하는것은, dfs를 처음 호출할때 depth가 0이기 때문이다.

dfs를 처음 호출한 경우 num은 0이고, 처음 0을 탐색할 경우도 num은 0 이지만, count에 차이가 존재한다.

dfs를 처음 호출했을 때는 answer를 갱신하지 말아야 한다.

백트래킹은 다음과 같다.

```cpp
for (int i = 0; i < 10; i++) {
  if (check[i]) continue;

  dfs();
}
```

이 경우 i가 0일 때 다음과 같이 진행될 수 있다.

```cpp
000001  // 버튼을 누른 횟수 : 6
1       // 버튼을 누른 횟수 : 1
```

두 경우 모두 1이지만 버튼을 누른 횟수가 다르다. 이 경우 아래 1인 경우가 버튼을 누른 횟수가 더 적으므로 1만 누른 경우로 anwser가 갱신된다.

따라서 최소값으로 answer를 구해야 하므로 앞에 0이 붙는것은 문제가 되지 않는다.

## 정리

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|      44      |       0        |

## 고생한 점

depth가 0 이상일 때만 answer를 갱신하지 않아 문제가 발생했다.
