# 1913. 달팽이

[링크](https://www.acmicpc.net/problem/1913)

|  난이도  | 정답률(\_%) |
| :------: | :---------: |
| Silver V |   56.632    |

## 설계

### 시간복잡도

1 부터 N^2 까지의 수를 채워야 하므로 시간복잡도는 O(N^2) 가 걸립니다.

여기서 N 최대 999이며 대략 1,000 으로 생각했을 때
최대 1,000,000 번의 연산을 수행함을 확인할 수 있습니다.

이는 1초 내에 충분히 연산이 가능한 범위이고, 문제의 시간제한은 2초이므로 조건을 충족합니다.

### 접근방법

문제의 접근방법은 다음 방법들이 존재합니다.

1. 첫번째 수 1부터 수를 채워넣는 방법
2. 제일 마지막 수 N^2부터 수를 채워넣는 방법
3. 위치 공식을 이용

여기서 1번 방법의 경우, 1의 위치는 항상 정 중앙으로 고정되어 있는것이 보장됩니다.

2번의 경우 맨 마지막 수의 위치에 대해 고민해야 합니다. 결과적으로 이 위치는 항상 2차원 배열에서 (0, 0)임이 보장됩니다.

이는 재미있게도 문제에서 주어지는 N이 홀수이기 때문입니다.

```sh
N = 3

↑→→
↑1↓
←←↓

N = 5
↑→→→→
↑↑→→↓
↑↑1↓↓
↑←←↓↓
←←←←↓
```

규칙이 보이시나요?

N이 증가할 때마다 이전 N-2인 모양에서 테두리를 한 겹 더 감싸는 형태의 모양이 됩니다.
테두리의 끝의 숫자는 항상 N^2 이며 좌표는 (0, 0)으로 고정입니다.

3번 방법의 경우는 이 테두리를 감싸는 것에서 풀이법을 찾을 수 있습니다.

각 숫자마다 좌표가 어떻게 되는지 찾는 함수 find(int x)를 선언한다고 합시다.

테두리를 감싸는 단계를 depth라고 표현한다면 다음과 같습니다.

```sh
1 : 1 depth
2 ~ 9 : 2 depth
10 ~ 25 : 3 depth
26 ~ 49 : 4 depth
```

규칙이 보이시나요? 각 depth의 끝 숫자를 봅시다

```sh
1, 9, 25, 49
```

이는 입력받은 N^2의 끝 숫자입니다. 따라서 특정 숫자가 몇 depth에 포함되어있는지 구할 수 있습니다.

다음으로 윗면, 오른쪽면, 아랫면, 왼쪽면 중 어느 면에 속하는지 알기 위해선 각 depth에 숫자가 총 몇개 있는지 알 필요가 있습니다.

```sh
1 depth : 1개
2 depth : 8개
3 depth : 16개
4 depth : 20개
```

depth가 1일때 빼고는 4의 배수로 늘어남을 알 수 있습니다. 이는 테두리를 감싸는 모양에서 알 수 있습니다.

따라서 depth를 찾은 후, 범위를 4등분 해 어느 면에 속하는지 찾을 수 있고, 이에 따라 좌표를 계산할 수 있습니다.

이 방법은 복잡하므로 추천하진 않습니다.

### 직진, 회전

위에 설명한 방법에서 1번, 2번 방법의 경우 각 경우마다 직진과 회전을 수행해야 합니다.

먼저 방향에 대한 정의를 내려야 합니다. 일반적으로 2차원 배열에서 상, 하, 좌, 우의 이동은 현재 좌표에서 변위값으로 나타냅니다.

```cpp
[y][x] // 현재 좌표

[y-1][x] // UP
[y+1][x] // DOWN
[y][x+1] // RIGHT
[y][x-1] // LEFT

// 이는 [0][0] 이 TOP LEFT인 경우
```

각 방향별로 (직진) 이동을 정의했으니 회전을 정의할 차례입니다.

1번 방법의 경우 회전의 방향이 시계방향임을 알 수 있습니다.

```sh
9→→
↑1↓
←←↓
```

2번 방법의 경우 회전은 반시계 방향입니다.

```sh
9←←
↓1↑
→→↑
```

방향은 4번 회전하면 원래 방향으로 돌아옵니다. 이를 구현하려면 MOD 연산을 이용하는 편이 좋습니다.

크기가 4인 배열을 선언하고, 회전은 다음과 같이 정의합니다.

```cpp
int rotate(int direction){
  return (direction + 1) % 4
}
```

이제 직진과 회전을 정의했습니다.

그렇다면 언제 직진하고 언제 회전해야 할까요?

1번 방법의 경우 직진과 회전의 분기는 다음과 같습니다.

1. 방향을 꺾었을 때 다음 좌표의 값이 0인 경우 : 회전
2. 직진했을 때 다음 좌표의 값이 0인 경우 : 직진

2번 방법의 경우 이보다 좀더 직관적입니다.

1. 직진했을 때 다음 숫자의 값이 0인 경우 : 직진
2. 직진했을 때 다음 숫자의 값이 0이 아닌 경우 : 회전

### 특정 숫자 T의 좌표를 찾기

만약 3번 방법으로 구현한 경우 find 함수에 특정 숫자 T를 입력하면 바로 좌표를 찾을 수 있습니다.

1번, 2번 방법으로 구현한 경우 T의 좌표를 찾는 방법은 다음과 같이 생각해 볼 수 있습니다.

1. 2차원 배열을 모두 채운 후 배열을 전부 순회하며 좌표를 찾는다.
2. 배열을 채워 넣을 때 T인지 검사 후 좌표를 저장해놓는다.

1번을 수행하는 경우 N^2 번 만큼 연산을 하기 때문에, 총 시간복잡도는 2 \* N^2가 될 것입니다. 상수를 빼는 경우 N^2이므로 큰 문제가 되지 않습니다.

2번방법의 경우 숫자를 채워넣을때마다 if문을 수행합니다.

## 정리

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|     104      |       28       |

## 고생한 점
