# 1068. 트리

[링크](https://www.acmicpc.net/problem/1068)

|  난이도  | 정답률(\_%) |
| :------: | :---------: |
| Silver I |   25.421    |

## 설계

### 시간 복잡도

트리에서 중간 정점을 끊은 후 탐색한다.

노드의 최대 개수는 50개이고, 모든 노드를 탐색한다고 할 때 시간 복잡도는

```bash
O(V + E) # 정점의 개수 + 간선의 개수
```

이다.

각 노드별로 2개의 간선을 가진다고 가정하면, 최악의 경우도 1,000을 넘지 않는다.

### 공간 복잡도

노드의 최대 개수는 50개이므로 size가 50인 Tree 배열을 생성한다.

Tree에 담길 정보는 다음과 같다.

- 부모의 index
- int[] 자식들의 index

이를 구조체로 선언해 관리한다.

```cpp
struct Tree {
  int parent;
  vector<int> links;
};
```

### 탐색

노드가 끊기는 경우는 다음과 같다.

탐색을 진행할 때 더이상 진행하지 않는 경우는 다음과 같다.

- 현재 index가 삭제한 index인 경우
- 이미 방문한 노드인 경우

또한 자식의 개수에 따라 분기 처리를 진행한다.

- 자식이 0개인 경우 : 리프노드
- 자식의 1개인 경우 :
  - 자식이 삭제된 노드이면 리프노드
- 자식이 1개 이상인 경우 (자식이 리프노드가 아닌경우):
  - 탐색을 이어감

또한 문제에서 탐색은 root에서만 진행해야 한다.

즉 노드를 삭제하고 나서의 모든 리프 노드를 구하는 것이 아니다.

## 정리

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|      0       |       0        |

## 고생한 점

모든 리프 노드를 구하는 문제가 아니였고, 자식 노드에 삭제된 노드가 있는 경우도 고려해야 함
